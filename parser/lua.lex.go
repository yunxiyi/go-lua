// Generated by golex
package lua


import (
	"bufio"
	"io"
	"os"
	"regexp"
	"sort"
)
import "fmt"
import "flag"
import "strings"

var yyin io.Reader = os.Stdin
var yyout io.Writer = os.Stdout

type yyrule struct {
	regexp     *regexp.Regexp
	trailing   *regexp.Regexp
	startConds []yystartcondition
	sol        bool
	action     func() yyactionreturn
}

type yyactionreturn struct {
	userReturn int
	returnType yyactionreturntype
}

type yyactionreturntype int
const (
	yyRT_FALLTHROUGH yyactionreturntype = iota
	yyRT_USER_RETURN
	yyRT_REJECT
)

var yydata string = ""
var yyorig string
var yyorigidx int

var yytext string = ""
var yytextrepl bool = true
func yymore() {
	yytextrepl = false
}

func yyBEGIN(state yystartcondition) {
	YY_START = state
}

func yyECHO() {
	yyout.Write([]byte(yytext))
}

func yyREJECT() {
	panic("yyREJECT")
}

var yylessed int
func yyless(n int) {
	yylessed = len(yytext) - n
}

func unput(c uint8) {
	yyorig = yyorig[:yyorigidx] + string(c) + yyorig[yyorigidx:]
	yydata = yydata[:len(yytext)-yylessed] + string(c) + yydata[len(yytext)-yylessed:]
}

func input() int {
	if len(yyorig) <= yyorigidx {
		return EOF
	}
	c := yyorig[yyorigidx]
	yyorig = yyorig[:yyorigidx] + yyorig[yyorigidx+1:]
	yydata = yydata[:len(yytext)-yylessed] + yydata[len(yytext)-yylessed+1:]
	return int(c)
}

var EOF int = -1
type yystartcondition int

var INITIAL yystartcondition = 0
var YY_START yystartcondition = INITIAL

type yylexMatch struct {
	index	  int
	matchFunc func() yyactionreturn
	sortLen   int
	advLen    int
}

type yylexMatchList []yylexMatch

func (ml yylexMatchList) Len() int {
	return len(ml)
}

func (ml yylexMatchList) Less(i, j int) bool {
	return ml[i].sortLen > ml[j].sortLen && ml[i].index > ml[j].index
}

func (ml yylexMatchList) Swap(i, j int) {
	ml[i], ml[j] = ml[j], ml[i]
}

func yylex() int {
	reader := bufio.NewReader(yyin)

	for {
		line, err := reader.ReadString('\n')
		if len(line) == 0 && err == io.EOF {
			break
		}

		yydata += line
	}

	yyorig = yydata
	yyorigidx = 0

	yyactioninline(yyBEGIN)

	for len(yydata) > 0 {
		matches := yylexMatchList(make([]yylexMatch, 0, 6))
		excl := yystartconditionexclmap[YY_START]

		for i, v := range yyrules {
			sol := yyorigidx == 0 || yyorig[yyorigidx-1] == '\n'

			if v.sol && !sol {
				continue
			}

			// Check start conditions.
			ok := false

			// YY_START or '*' must feature in v.startConds
			for _, c := range v.startConds {
				if c == YY_START || c == -1 {
					ok = true
					break
				}
			}

			if !excl {
				// If v.startConds is empty, this is also acceptable.
				if len(v.startConds) == 0 {
					ok = true
				}
			}

			if !ok {
				continue
			}

			idxs := v.regexp.FindStringIndex(yydata)
			if idxs != nil && idxs[0] == 0 {
				// Check the trailing context, if any.
				checksOk := true
				sortLen := idxs[1]
				advLen := idxs[1]

				if v.trailing != nil {
					tridxs := v.trailing.FindStringIndex(yydata[idxs[1]:])
					if tridxs == nil || tridxs[0] != 0 {
						checksOk = false
					} else {
						sortLen += tridxs[1]
					}
				}

				if checksOk {
					matches = append(matches, yylexMatch{i, v.action, sortLen, advLen})
				}
			}
		}

		if yytextrepl {
			yytext = ""
		}

		sort.Sort(matches)

	tryMatch:
		if len(matches) == 0 {
			yytext += yydata[:1]
			yydata = yydata[1:]
			yyorigidx += 1

			yyout.Write([]byte(yytext))
		} else {
			m := matches[0]
			yytext += yydata[:m.advLen]
			yyorigidx += m.advLen

			yytextrepl, yylessed = true, 0
			ar := m.matchFunc()

			if ar.returnType != yyRT_REJECT {
				yydata = yydata[m.advLen-yylessed:]
				yyorigidx -= yylessed
			}

			switch ar.returnType {
			case yyRT_FALLTHROUGH:
				// Do nothing.
			case yyRT_USER_RETURN:
				return ar.userReturn
			case yyRT_REJECT:
				matches = matches[1:]
				yytext = yytext[:len(yytext)-m.advLen]
				yyorigidx -= m.advLen
				goto tryMatch
			}
		}
	}

	return 0
}
var XLONGSTRING yystartcondition = 1024
var XSHORTCOMMENT yystartcondition = 1025
var XLONGCOMMENT yystartcondition = 1026
var XSTRINGQ yystartcondition = 1027
var XSTRINGA yystartcondition = 1028
var yystartconditionexclmap = map[yystartcondition]bool{XLONGSTRING: true, XSHORTCOMMENT: true, XLONGCOMMENT: true, XSTRINGQ: true, XSTRINGA: true, }
var yyrules []yyrule = []yyrule{{regexp.MustCompile("^#![^\\n]*"), nil, []yystartcondition{}, true, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	{
	}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("and"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	{
		return yyactionreturn{TK_AND, yyRT_USER_RETURN}
	}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("break"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_BREAK, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("do"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_DO, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("else"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_ELSE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("elseif"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_ELSEIF, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("end"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_END, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("false"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_FALSE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("for"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_FOR, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("function"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_FUNCTION, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("if"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_IF, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("in"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_IN, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("local"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_LOCAL, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("nil"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_NIL, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("not"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_NOT, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("or"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_OR, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("repeat"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_REPEAT, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("return"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_RETURN, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("then"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_THEN, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("true"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_TRUE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("until"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_UNTIL, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("while"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_WHILE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("(([0-9]+)|([0-9]+)[.]([0-9]+))([Ee][+-]?{n})?"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_NUMBER, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("([_a-zA-Z][_a-zA-Z0-9]*)"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_NAME, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("--\\[\\["), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yyBEGIN(XLONGCOMMENT)
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("--"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	yyBEGIN(XSHORTCOMMENT)
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\[\\[(([ \\t\\v\\a]*)\\n)?"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	yyBEGIN(XLONGSTRING)
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("([ \\t\\v\\a]+)"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_WHITESPACE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\.\\.\\."), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_DOTS, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\.\\."), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_CONCAT, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("=="), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_EQ, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile(">="), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_GE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("<="), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_LE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("~="), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_NE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("-"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\+"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\*"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("/"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("="), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile(">"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("<"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\("), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\)"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\["), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\]"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\{"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\}"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\n"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_NEWLINE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\r"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{TK_NEWLINE, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\""), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	yyBEGIN(XSTRINGQ)
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("'"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	yyBEGIN(XSTRINGA)
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[^\\n]"), nil, []yystartcondition{}, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	return yyactionreturn{int([]byte(yytext)[0]), yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\"\\\""), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\""), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yyBEGIN(0)
	return yyactionreturn{TK_STRING, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\[abfnrtv]"), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\n"), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\\""), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\'"), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\["), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\]"), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[\\n|\\r]"), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	{
		fmt.Printf("unterminated string.\n")
		yyBEGIN(0)
		return yyactionreturn{TK_STRING, yyRT_USER_RETURN}
	}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[^\\n]"), nil, []yystartcondition{XSTRINGQ, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("''"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("'"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yyBEGIN(0)
	return yyactionreturn{TK_STRING, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\[abfnrtv]"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\n"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\\""), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\'"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\["), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\\\\\]"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[\\n|\\r]"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	{
		fmt.Printf("unterminated string.\n")
		yyBEGIN(0)
		return yyactionreturn{TK_STRING, yyRT_USER_RETURN}
	}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[^\\n]"), nil, []yystartcondition{XSTRINGA, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\]\\]"), nil, []yystartcondition{XLONGSTRING, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yyBEGIN(0)
	return yyactionreturn{TK_LONGSTRING, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\n"), nil, []yystartcondition{XLONGSTRING, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\r"), nil, []yystartcondition{XLONGSTRING, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[^\\n]"), nil, []yystartcondition{XLONGSTRING, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\n"), nil, []yystartcondition{XSHORTCOMMENT, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yyBEGIN(0)
	return yyactionreturn{TK_SHORTCOMMENT, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\r"), nil, []yystartcondition{XSHORTCOMMENT, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yyBEGIN(0)
	return yyactionreturn{TK_SHORTCOMMENT, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[^\\n]"), nil, []yystartcondition{XSHORTCOMMENT, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\]\\]--"), nil, []yystartcondition{XLONGCOMMENT, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yyBEGIN(0)
	return yyactionreturn{TK_LONGCOMMENT, yyRT_USER_RETURN}
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\n"), nil, []yystartcondition{XLONGCOMMENT, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("\\r"), nil, []yystartcondition{XLONGCOMMENT, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, {regexp.MustCompile("[^\\n]"), nil, []yystartcondition{XLONGCOMMENT, }, false, func() (yyar yyactionreturn) {
	defer func() {
		if r := recover(); r != nil {
			if r != "yyREJECT" {
				panic(r)
			}
			yyar.returnType = yyRT_REJECT
		}
	}()
	yymore()
	return yyactionreturn{0, yyRT_FALLTHROUGH}
}}, }
func yyactioninline(BEGIN func(yystartcondition)) {}
var lineNo, linePos int
func ParseLexer() {
	flag.Parse()
	if flag.NArg() > 0 {
		yyin, _ = os.Open(flag.Arg(0))
	} else {
		yyin = os.Stdin
	}
    lineNo = 1
	for tok := yylex(); tok > 0; tok = yylex() {
        if tok == TK_WHITESPACE  {
            linePos = linePos + len(yytext)
            continue
        }
        if tok == TK_NEWLINE{
            lineNo = lineNo + 1
            linePos = 0
            continue
        }
        fmt.Printf("%05d \t %05d \t %05d \t %-13.13s:  %s\n", tok, lineNo, linePos, TokenName(tok), yytext)
        linePos = linePos + len(yytext)
        newLineCnt := strings.Count(yytext, "\n")
        if newLineCnt > 0 {
            linePos = 0
        }
        lineNo = lineNo + strings.Count(yytext, "\n")
    }
}
